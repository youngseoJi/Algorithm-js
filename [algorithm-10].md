## [algorithm] JS - 예산 내 줄 수 있는 최대 선물개수 (완전탐색)

> 완전탐색 문제 : 현재 예산으로 최대 몇 명에게 선물을 사줄 수 있는지 출력해라

>
> - 입력 : 반 학생수 n (1<=N<=1000), 예산 m (1<=M<=100,000,000)
>     n줄에 걸쳐 각 학생들이 받고 싶은 상품의 가격과 배송비가 입력
> - 배열요소 : [가격,배송비], [가격,배송비], [가격,배송비]

>조건1: 상품 한개만 50% 할인(반 가격) 살 수 있는 쿠폰이 있다, 배송비는 할인에 포함되지 않습니다.
>조건2: 상품가격은 짝수로만 입력
>조건3: 상품가격과 배송비는 각각 100,000을 넘지 않는다. 
>조건4: 최소한 1개 이상의 상품을 살 수 있는 예산을 가지고 있다.



## 접근 방식
예산내에 최대한 많은 학생에게 선물을 사줘야하니, 가격과 배송비를 더한 값-> 총비용이 가장 저렴한 선물들을 우선순위로 선물한다!
- **막힌 부분 주의!**
-> 한 상품만 적용되는 반값 할인쿠폰, 어떤 상품을 반값 할인했을때 가장 많은 개수의 선물을 할수 있을지 생각해라
선생님 풀이설명을 듣자 완전탐색문제라고 하며 완전히 다 탐색하는 방법을 설명해주심! 
-> 모든 상품에 50%할인쿠폰을 한번씩 꼭 ! 적용해봐야한다.

## 풀이
1. 최대한 많은 개수의 선물을 주기위해, 상품가격과 배송비를 더한 값 === 총비용이 낮은 순(오름차순)으로 정렬한다. -> 오름차순 정렬 기본식 sort((a,b) => a-b)
-> [a선물가격, b배송비] === a[0], a[1]번째요소
2. for문) 모든 상품을 조회한다.
3. 할인한 상품가격 -> 모든 상품을 순서대로 i번째의 0번쨰 요소(상품가격)을 반값할인한 가격과 + 배송비를 더한값을 구한다.
      -> (product[i][0]/2 + product[i][1])
4. m 예산 - 할인한 상품가격한 남은 예산을 담을 변수를 선언하고 담는다.
5. 이중for문) 모든 상품을 조회한다.
6. if조건 ) i(할인한 상품)이 아니고, 상품가격과 배송비를 더한 값이 남은 예산보다 작거나 같을경우
-> 나머지 모든 상품을 조회하여 해당 상품가격과 배송비를 더한 값을 반복하여 남은예산에서 뺀다.
7. 효율적인 탐색을 위한 if 조건) 상품가격과 배송비를 더한 값이 남은 예산보다 큰경우 더이상 상품을 조회하지않는다. -> break문
8. 남은예산에서 뺄때 마다 cnt++ 을 하여 선물의 개수를 센다.
9. break문 조건이될경우 반복문을 탈출한다.

10. 반복해서 maxCnt와 cnt를 비교 -> 가장 많은 선물개수를 maxcnt에 담는다.
          maxCnt = Math.max(maxCnt, cnt);

6. ```js
       function solution(m, product) {
           // 최대 선물 개수를 세자
           let maxCnt = 0;
   
           // 작은 총비용 순대로 오름차순 정렬 [a선물가격, b배송비] === a[0], a[1]번째요소
           product.sort((a, b) => a[0] + a[1] - b[0] + b[1]);
           for (let i = 0; i < product.length; i++) {
             // 예산 m 에서 할인한 상품가격을 제외하고 남은 예산을 변수에 담는다.
             let money = m - (product[i][0] / 2 + product[i][1]);
   
             for (let j = 0; j < n; j++) {
               // 효율적인 탐색을 위해 
   						//-> 상품가격과 배송비를 더한 값이 남은 예산보다 큰경우 더이상 상품을 조회하지않는다. 
               if (j !== i && product[j][0] + product[j][1] > money) break;
               // i(할인한 상품)이 아니고, 상품가격과 배송비를 더한 값이 남은 예산보다 작거나 같을경우
               if (j !== i && product[j][0] + product[j][1] <= money) {
                 // 남은 예산에 반복적으로 상품가격과 배송비를 더한 값을 뺀다.
                 money -= product[j][0] + product[j][1];
                 // 뺄때 마다 cnt++ 을 하여 상품개수를 센다.
                 cnt++;
               }
             }
             // 반복해서 maxCnt와 cnt를 비교 -> 가장 많은 선물개수를 maxcnt에 담는다.
             maxCnt = Math.max(maxCnt, cnt);
           }
           return maxCnt;
         }
   
         let arr = [
           [6, 6],
           [2, 2],
           [4, 3],
           [4, 5],
           [10, 3],
         ];
         console.log(solution(28, arr));