## [Two Pointers Algorithm-2]  공통원소구하기

---



> 문제 : 두 배열의 공통 원소를 오름차순으로 출력해라

  > 입력 : 자연수의 10000이하의 자연수
  >
  > 조건 1 : 각 배열의 원소가 중복되지 않는다. (한 배열안에 같은 원소 x)

## 풀이 
1. 두 배열을 오름차순으로 순차적으로 비교할 수 있도록, sort()오름차 순으로 정렬한다. 
     -> arr1.sort((a, b) => a - b)
2. 두 배열의 인덱스를 변수 p1, p2 두 포인트를 잡고 첫번째 요소부터 비교하기 위해 0을 할당한다. 
      -> arr1[p1] / arr[0]번째 인덱스부터 조회, 비교 시작
3. while문으로 p1, p1가 배열의 길이보다 크거가 같아지는 경우 while문을 멈춘다.
     -> 인덱스나 배열길이와 같거나 커지는 경우는 없다! 배열요소 다 조회한 것 
4. 공통원소를 찾으면, 즉 두 배열의 p1,p2 인덱스번째 요소가 같다면?
    -> answer배열에 arr1요소를 담는다.
5. 다음 요소를 비교하기 위해 각 요소의 인덱스에 ++1을 더해준다.  
    -> p1++, p2++
    
### 중요 접근방식 공통원소가 아닌경우(오름차순 정력 기억) 
- 두 배열요소 비교 -> 작은 요소의 배열 인덱스 ++1 해서 다음 요소를 조회하여 비교한다. 
	-> 왜냐? 오름차순이기 때문!  큰요소의 인덱스에 ++1 하면 ? 
    -> 다음요소는 더 큰 요소가 되고 다른 배열의 작은 요소와 비교하여 공통원소를 구할 수 없다.        
  

6-1. 공통원소가 아닌경우? arr1[p1]요소가 arr2[p2]요소 보다 작으면 p1인덱스 ++1을 더해준다.
6-2. 공통원소가 아닌경우? arr2[p2]요소가 arr1[p1]요소 보다 작으면 p2인덱스 ++1을 더해준다.


```js
      function solution(arr1, arr2) {
        let answer = [];
        arr1.sort((a, b) => a - b);
        arr2.sort((a, b) => a - b);
        let p1 = (p2 = 0);
        while (p1 < arr1.length && p2 < arr2.length) {
          if (arr1[p1] == arr2[p2]) {
            answer.push(arr1[p1++]);
            p2++;
          } else if (arr1[p1] < arr2[p2]) p1++;
          else p2++;
        }
        return answer;
      }

      let a = [1, 3, 9, 5, 2];
      let b = [3, 2, 5, 7, 8];
      console.log(solution(a, b));
```