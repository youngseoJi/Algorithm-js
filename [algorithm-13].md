## [Algorithm/투포인터 알고리즘-3]  연속부분수열 합이 특정숫자가 되는 경우 횟수

---

> 문제 : 이 수열에서 연속부분수열의 합이 특정숫자 M이 되는 경우가 몇 번 있는지 출력해라

  > 입력 : 수열의 원소값은 1,000을 넘지 않는 자연수

  ## 접근방식

  - 왼쪽 left번째 요소부터 오른쪽 light번째 까지의 요소의 합 sum이 6인 경우를 세주면된다.
    -> 계속 right++해주며 요소를 순차적으로 더해주다 6인 경우! 개수 1개 더하기 
    -> 아닌 경우도 구해주기 left번째 요소를 ++해서 범위를 좁히는식 ) 범위를 좁힐때 p1요소를 더했던 값은 - 빼줘야한다.

  ## 풀이

    1. 합의 개수를 세줄 변수 cnt 초기값 0할당, 연속부분수열의 합을 담을 sum변수를 선언, 초기값 배열의 처음요소를 할당한다
       -> 배열의 0번째 요소부터 합해줄거여서 arr[0]할당한 것

    2. 투 포인트 변수 left(오른쪽 포인트 변수의 합이 보다 작을때 제거될 요소를 가리킴), right(합해줄 요소)
       -> left, light는 인덱스 (초기 0번째 인덱스)

    3. while문으로 배열의 마지막 인덱스가 배열의 길이랑 같거나 크면 반복문을 멈추고 결과를 리턴하도록 함.
       -> 그러면 모든 요소를 돌아본 것이 때문!

    4. sum 부분수열의 합이 m 주어진 수와 같은경우? 
       -> cnt에 1을 더해주고, 왼쪽 요소를 삭제, 왼쪽요소에서 오른쪽으로 한칸 이동한다. 

    5. sum 부분수열의 합이 m 주어진 수보다 작은 경우?
       -> 오른쪽 인덱스 1 더해주기, 오른쪽으로 이동하여 위치한 해당 요소를 더함

    6. sum 부분수열의 합이 m 주어진 수와 같은경우? 
       -> 왼쪽 요소를 삭제, 왼쪽요소에서 오른쪽으로 한칸 이동한다. 

    7. whil문 종료 후 cnt 횟수 리턴. 

```js
      function solution(m, arr) {
        let cnt = 0;
        let left = 0;
        let right = 0;
        let sum = arr[0];

        // 인덱스가 배열의 길이랑 같거나 커지면 while문 탈출
        // 배열의 모든 요소를 조회한 것이기 때문
        while (right < arr.length) {
          // sum 부분수열 합이 m과 같다면 ? cnt++
          if (sum === m) {
            cnt++;
            // 합 에서 left 번째 인덱스 요소를 뺀다.
            sum -= arr[left];
            // 오른쪽 범위로 한칸 ++ 해서 왼쪽 범위 줄이기
            left++;
          }
          // 부분수열의 합이 m 보다 작다면?
          if (sum < m) {
            // right++ 1을 더해줘서 오른쪽으로 범위를 증가
            right++;
            // right++ 한 light번째 요소를 더해준다. 오른쪽으로 범위가 1 증가한 것
            sum += arr[right];
          }
          // 부분수열의 합이 m보다 큰 경우
          else {
            // 왼쪽 범위 left번째 요소 빼기
            sum -= arr[left];
            // 오른쪽 범위로 한칸 ++ 해서 왼쪽 범위 줄이기
            left++;
          }
        }
        return cnt;
      }

      let a = [1, 2, 1, 3, 1, 1, 1, 2];
      console.log(solution(6, a));
```
## 선생님 코드

```js
 function solution(m, arr) {
        let cnt = 0;
        let left = 0;
        let sum = 0; // arr[0]할당해줘도된다.
   
		// 모든 배열의 요소를 조회한다.
        for (let right = 0; right < arr.length; right++) {
          // right++ 한 right번째 요소를 더해준다. 오른쪽으로 범위가 1 증가한 것
          sum += arr[right];
          if (sum === m) {
            // right++ 1을 더해줘서 오른쪽으로 범위를 증가
            cnt++;
          }

          // 부분수열의 합이 m보다 크거나 작을 경우 (아닌 경우 탈출)
          while (sum >= m) {
            // 왼쪽 범위 left번째 요소 빼기, 그다음 ++ 왼쪽에서 오른쪽으로 1칸이동 범위 줄이기
            sum -= arr[left];
            left++;
            if (sum === m) {
              cnt++;
            }
          }
        }
        return cnt;
      }

      let a = [1, 2, 1, 3, 1, 1, 1, 2];
      console.log(solution(6, a));
```
