## [algorithm] JS - 자릿수 합이 최대인 수 구하기 (문자열, while()문, %10 활용 )

---



  >**문제 : 자연수의 자릿수 합을 구하고, 그 합이 최대인 자연수를 출력해라.  (10,000,000 < 자연수)
  >예외조건) 자릿수의 합이 같을 경우 원래 숫자가 큰 숫자를 출력한다.**

### 풀이

1. 결과를 담을 변수 result를 선언하고,
가장 큰 자릿수의 합을 담을 max 변수를 선언한다. max에는 자연수에서 가장 작은 수인 0을 담는다.
-> 0을 사용하는 이뉴는 비교하는 값에  영향을 주지 않는 수를 사용한것이며, 
-> 가장 작은 수를 사용하는 이유는 가장 큰 값을 구해야하기 때문에 반복적으로 다른 요소의 합와 비교하며 큰 합의 값을 max에 반복적으로 담아줄 것이기 때문이다.
2. for of 문 ->  배열의 요소를 모두 조회하며, 각 요소의 자릿수를 더해주기 위해 모두 문자열로 변환하고, 
        한 자릿 수로 잘라준다. -> map, toString().split("") 
      -> ['1', '2', '8'], ['4', '6', '0']....
3. reduce 고차함수로 배열의 각 요소에 담긴, 각 한자릿수의 요소들을 모두 더해줘서 자릿 수의 합을 구한다.
4. 문자열 형태이기에 더하기를 하기 위해 더할때 수 타입으로 변환한다. -> number()  
5. 더하는 자릿수의 합은 변수 sum에 담아준다.
6. max =가장 큰수보다 sum = 자릿수의 합이 크다면 ? -> max에 sum의 값을 담아주는 것을 반복한다.
7. 반복하여 자릿수의 합이 가장 큰 원본 배열의 요소 el을 결과를 담을 result 변수에 담아준다.
8. 예외조건) max와 sum이 같다면 ? 
    -> 자릿 수의 합이 같은 요소가 있을 경우 원본 요소를 수를 비교하여 더 큰 수를 담아준다.
9. result 가장 큰 자릿수의 합을 가진, 원본 요소를 출력한다. 
   
   
    ```js
    function solution(arr) {
        let result = 0;
        let max = 0;
        for (let el of arr){
          let sum = el.toString().split("").reduce((acc,cur)=>{
          acc + number(cur)
          // 누적, 현재값
        },0)
    
            if(sum > max){
                sum = max;
                result = el
            }
            //예외) 같은 자릿수의 합을 가졌다면
            else if (sum === max){
                // 현재 조회한 원본요소가 직전에 result에 담은 원본요소보다 크다면 
              if(el > result){
                  // result에 현재 원본요소를 담는다.
                result = el;
              }
            }
        }
        return result
        // 가장 큰 자릿수의 합을 가진 원본 요소가 출력된다. (예외 동일한 자릿수합일 경우 더 큰 원본 넘버타입의 요소가 담긴다)
      }
    
      let arr = [128, 460, 603, 40, 521, 137, 123];
      console.log(solution(arr));

## 새로 배운 방법 : while()문, %10 활용


- **위의 방식과 다른 부분 - 자릿 수의 합을 구하는 방법이 다르다.**
>
> 해당 배열의 요소를 10으로 나누어 떨어지는 값(몫)을 구한다.
> 배열의 요소의 값이 0이 되면 while문을 종료하고 탈출한다.
>자릿수의 합은 배열의 요소를 10으로 나누고 떨어지는 값(몫)을 sum에 누적해서 합해준다.
>

- **128의 자릿수 합 구하는 예시**
  
>-> 128의 자릿수는 10으로 0이 될때 까지 수를 나누어 떨어진 값들을 더한 8 + 2 + 1 + 0 = 11 이다.**
> ![](https://images.velog.io/images/estell/post/492ad2a9-f29d-455c-a766-5f6cdd2ca193/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-10%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.15.28.png)


 ```js
function solution(arr)  {
        let result = 0;
        let max = 0;
        for (let el of arr){
          let sum = 0, newEl=el;
      
          while(el2){
          sum+=(el2%10); 
          el2=Math.floor(el2/10); 
        }
        console.log(sum);

          if(sum > max){
            sum = max;
            result = el
            }
            
          else if (sum === max){
            if(el > result){
              result = el;
            }
          }
        }
        return result
        // 가장 큰 자릿수의 합을 가진 원본 요소가 출력된다. (예외 동일한 자릿수합일 경우 더 큰 원본 넘버타입의 요소가 담긴다)
      }

      let arr = [128, 460, 603, 40, 521, 137, 123];
      console.log(solution(arr));
 ```